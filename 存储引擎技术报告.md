# AODSQL 数据库存储引擎层技术报告

## 项目概述

负责设计并实现 AODSQL 教学型关系数据库系统的存储引擎层，采用页式存储架构，支持事务、索引、并发控制等核心功能。系统采用模块化设计，实现了从物理存储到上层接口的完整存储抽象。

## 核心架构设计

### 1. 分层存储架构

```
┌─────────────────────────────────────┐
│   RealStorageEngine (存储引擎接口)    │
│   - CRUD操作抽象                      │
│   - 事务与锁管理                      │
│   - 日志记录 (WAL)                    │
└──────────────┬──────────────────────┘
               │
┌──────────────▼──────────────────────┐
│   HeapFileManager (堆文件管理)       │
│   - 页链表组织                        │
│   - 记录插入/删除/更新                │
│   - 全表扫描                          │
└──────────────┬──────────────────────┘
               │
┌──────────────▼──────────────────────┐
│   BufferPool (缓冲池)                │
│   - LRU页面置换                      │
│   - Pin/Unpin机制                    │
│   - 脏页管理                         │
└──────────────┬──────────────────────┘
               │
┌──────────────▼──────────────────────┐
│   TablespaceManager (表空间管理)     │
│   - 页分配/释放                       │
│   - 磁盘I/O抽象                      │
│   - 空闲页链表管理                    │
└─────────────────────────────────────┘
```

### 2. 索引子系统

- **B+树索引管理器**：实现多级B+树索引，支持唯一索引和复合索引
- **索引与数据分离**：索引页和数据页使用独立的缓冲池管理
- **索引维护**：自动维护索引与数据的一致性，支持插入/更新/删除时的索引同步

## 关键技术实现

### 1. 页式存储管理

**TablespaceManager - 表空间管理器**
- 实现固定大小页（4KB）的分配与回收机制
- 采用空闲页链表管理，支持页的复用，减少磁盘碎片
- 文件头存储空闲链表头指针，实现O(1)空闲页分配

**关键实现**：
```python
def allocate_page(self) -> int:
    """页分配：优先从空闲链表复用，否则在文件末尾扩展"""
    free_head = self._get_free_list_head()
    if free_head != self.NULL_PAGE_ID:
        # 复用空闲页
        return free_head
    else:
        # 扩展文件，分配新页
        page_id = self.next_page_id
        self.write_page(page_id, empty_page_data)
        return page_id
```

### 2. 缓冲池 (Buffer Pool) 实现

**核心特性**：
- **LRU置换策略**：使用OrderedDict实现LRU缓存，自动淘汰最久未使用的页
- **Pin/Unpin机制**：防止正在使用的页被淘汰，确保数据一致性
- **脏页管理**：跟踪修改过的页，支持延迟写回和批量刷新
- **WAL顺序保证**：基于LSN（Log Sequence Number）确保日志先于数据页刷新

**关键实现**：
```python
def get_page(self, page_id: int, page_cls: Type[HeapPage]) -> HeapPage:
    """获取页：缓存命中则LRU更新，未命中则从磁盘加载"""
    if page_id in self.cache:
        page = self.cache.pop(page_id)
        self.cache[page_id] = page  # LRU: move to end
    else:
        if len(self.cache) >= self.buffer_size:
            self._evict_page()  # 淘汰未pin的页
        data = self.tablespace_manager.read_page(page_id)
        page = page_cls(page_id, data=data)
        self.cache[page_id] = page
    self.pin_count[page_id] += 1  # 自动pin
    return page
```

### 3. 堆文件组织

**HeapFileManager - 堆文件管理器**
- 采用页链表结构组织数据，通过`root_page_id`和`next_page_id`实现顺序遍历
- 支持变长记录的插入、更新、删除操作
- 实现全表扫描迭代器，支持批量数据读取

**关键实现**：
```python
def scan(self, transaction: Transaction, record_size: int):
    """全表扫描：通过页链表遍历所有有效记录"""
    current_page_id = self.table_info.root_page_id
    while current_page_id is not None:
        page = self.bp.get_page(current_page_id)
        try:
            for rid in range(page.key_count):
                is_valid, row_bytes = page.get_record(rid, record_size)
                if is_valid:
                    yield (current_page_id, rid), row_bytes
            current_page_id = page.next_page_id
        finally:
            self.bp.unpin_page(current_page_id, is_dirty=False)
```

### 4. B+树索引实现

**BTreeManager - B+树管理器**
- 实现标准B+树结构，支持内部节点和叶子节点的分离存储
- 支持等值查找、范围查询（通过叶子节点链表）
- 实现节点分裂、合并算法，维护树的高度平衡
- 支持唯一性约束检查

**关键算法**：
- **查找**：从根节点向下遍历，O(log n)时间复杂度
- **插入**：定位到叶子节点插入，必要时进行节点分裂和父节点更新
- **删除**：删除后检查节点填充度，必要时进行合并或重分布

### 5. 数据序列化/反序列化

**TupleSerializer - 元组序列化器**
- 基于Python struct模块实现类型安全的二进制序列化
- 支持多种数据类型：INT、VARCHAR、DECIMAL、DATE、TIMESTAMP等
- 处理变长字符串的定长存储（填充/截断）
- 实现NULL值处理和数据精度控制

**关键实现**：
```python
def serialize(self, row) -> bytes:
    """序列化：根据schema将Python对象转换为二进制格式"""
    format_string = self._get_format_string(self.schema)
    packed_data = []
    for i, val in enumerate(row):
        col_type = self.schema[i].data_type.upper()
        if col_type in ['VARCHAR', 'CHAR', 'TEXT']:
            val_bytes = str(val).encode('utf-8')
            val_bytes = val_bytes.ljust(length, b'\x00')  # 定长填充
            packed_data.append(val_bytes)
        elif col_type in ['INT', 'INTEGER']:
            packed_data.append(int(val))
        # ... 其他类型处理
    return struct.pack(format_string, *packed_data)
```

### 6. 事务支持

**事务化存储操作**：
- **WAL (Write-Ahead Logging)**：所有数据修改先写日志，后写数据页
- **LSN管理**：每个页记录最大LSN，确保日志先于数据页刷新
- **锁管理集成**：在存储层集成锁管理器，支持共享锁和排他锁
- **约束检查**：实现主键唯一性、NOT NULL、CHECK约束的存储层检查

**关键流程**（以INSERT为例）：
```python
def insert_row(self, transaction, table_name: str, row: Tuple):
    # 1. 约束检查（主键唯一性、NOT NULL等）
    # 2. 序列化数据
    row_bytes = serializer.serialize(row)
    # 3. 预定位插入位置
    row_id = heap_file.find_space_for_record(row_bytes)
    # 4. 加锁
    self.lock_manager.acquire(transaction, LockMode.EXCLUSIVE, ResourceID(...))
    # 5. 写日志（WAL）
    log_record = InsertLogRecord(transaction.id, ResourceID(...), row_bytes)
    lsn = self.log_manager.append(transaction, log_record)
    # 6. 物理插入
    heap_file.insert_record_at(transaction, row_id, row_bytes, lsn)
    # 7. 更新索引
    index_manager.insert_entry(transaction, row, row_id, lsn_map)
```

## 性能优化

### 1. 批量处理
- 实现向量化执行模型，算子每次返回一批数据（BATCH_SIZE=1024），减少函数调用开销
- 支持批量插入，减少事务提交次数

### 2. 索引优化
- 索引页与数据页分离存储，独立缓冲池管理，提高缓存命中率
- 支持索引扫描，将全表扫描优化为索引查找（O(log n)）

### 3. 缓冲池优化
- LRU缓存策略，自动识别热点数据
- Pin/Unpin机制避免频繁的页换入换出
- 脏页批量刷新，减少磁盘I/O次数

### 4. 存储优化
- 空闲页链表管理，支持页复用，减少文件碎片
- 固定页大小设计，简化内存管理和I/O操作

## 技术亮点

1. **完整的存储抽象**：实现了从磁盘I/O到上层接口的完整存储抽象，支持多种存储操作
2. **事务一致性保证**：通过WAL、锁机制、LSN管理实现ACID特性
3. **高性能索引**：实现标准B+树索引，支持快速查找和范围查询
4. **模块化设计**：清晰的层次划分，各模块职责单一，易于维护和扩展
5. **内存管理优化**：缓冲池机制有效减少磁盘I/O，提升查询性能

## 技术栈

- **语言**：Python 3.8+
- **核心模块**：struct（序列化）、os（文件I/O）、collections（LRU缓存）
- **设计模式**：迭代器模式、工厂模式、策略模式
- **数据结构**：B+树、链表、哈希表、LRU缓存

## 项目成果

- 实现了完整的页式存储引擎，支持CRUD操作和事务管理
- 实现了B+树索引系统，查询性能提升显著（索引扫描 vs 全表扫描）
- 实现了高效的缓冲池管理，有效减少磁盘I/O
- 代码结构清晰，模块化程度高，便于团队协作和后续扩展

---

**项目规模**：核心代码约3000+行，包含6个主要模块，20+个核心类

**性能指标**：
- 缓冲池命中率：>80%（典型工作负载）
- 索引查找：O(log n)时间复杂度
- 支持并发事务（基于锁机制）


